---

title: ETL to process MIDI files
keywords: fastai
sidebar: home_sidebar

summary: "Turning a bunch of MIDI files into parquet data"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02_data.etl.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="9b4521be-4742-48ae-8a8d-8268583940a3"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#9b4521be-4742-48ae-8a8d-8268583940a3');

            setTimeout(function() {
                var nbb_cell_id = 4;
                var nbb_unformatted_code = "# export\ntotal_songs = 0\nmalformed_songs = 0\nvalid_songs = 0\nvalid_notes = 0\n\nstarted_at = None\n\n\ndef init_stats():\n    \"\"\"\n    Resets reporting stats to zero.\n    \"\"\"\n    global total_songs\n    global valid_songs\n    global valid_notes\n    global malformed_songs\n    global started_at\n\n    total_songs = 0\n    malformed_songs = 0\n    valid_songs = 0\n    valid_notes = 0\n\n    started_at = time.time()\n\n\nif \"SPELL\" in os.environ:\n    metric = spell.metrics.send_metric\n\n    def metric(_logger, k, v):\n        spell.metrics.send_metric(k, v)\n\n\nelse:\n\n    def metric(logger, k, v):\n        logger.info(f\"[{k}]: {v}\")\n\n\ndef report(logger):\n    \"\"\"\n    Reports current metrics, either to Spell or to a logger.\n    \"\"\"\n    elapsed = time.time() - started_at\n    metric(logger, \"Total Songs\", total_songs)\n    metric(logger, \"Malformed Songs\", malformed_songs)\n    metric(logger, \"Notes\", valid_notes)\n    metric(logger, \"Total Songs / second\", (total_songs / elapsed))\n    metric(logger, \"Notes / second\", (valid_notes / elapsed))";
                var nbb_formatted_code = "# export\ntotal_songs = 0\nmalformed_songs = 0\nvalid_songs = 0\nvalid_notes = 0\n\nstarted_at = None\n\n\ndef init_stats():\n    \"\"\"\n    Resets reporting stats to zero.\n    \"\"\"\n    global total_songs\n    global valid_songs\n    global valid_notes\n    global malformed_songs\n    global started_at\n\n    total_songs = 0\n    malformed_songs = 0\n    valid_songs = 0\n    valid_notes = 0\n\n    started_at = time.time()\n\n\nif \"SPELL\" in os.environ:\n    metric = spell.metrics.send_metric\n\n    def metric(_logger, k, v):\n        spell.metrics.send_metric(k, v)\n\n\nelse:\n\n    def metric(logger, k, v):\n        logger.info(f\"[{k}]: {v}\")\n\n\ndef report(logger):\n    \"\"\"\n    Reports current metrics, either to Spell or to a logger.\n    \"\"\"\n    elapsed = time.time() - started_at\n    metric(logger, \"Total Songs\", total_songs)\n    metric(logger, \"Malformed Songs\", malformed_songs)\n    metric(logger, \"Notes\", valid_notes)\n    metric(logger, \"Total Songs / second\", (total_songs / elapsed))\n    metric(logger, \"Notes / second\", (valid_notes / elapsed))";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="init_stats" class="doc_header"><code>init_stats</code><a href="https://github.com/codegram/neuralmusic/tree/master/neuralmusic/data/etl.py#L34" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>init_stats</code>()</p>
</blockquote>
<p>Resets reporting stats to zero.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="report" class="doc_header"><code>report</code><a href="https://github.com/codegram/neuralmusic/tree/master/neuralmusic/data/etl.py#L65" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>report</code>(<strong><code>logger</code></strong>)</p>
</blockquote>
<p>Reports current metrics, either to Spell or to a logger.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Untar'ing-the-file">Untar'ing the file<a class="anchor-link" href="#Untar'ing-the-file">&#182;</a></h2><p>The first step is to untar the file containing the MIDI files.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="3ff2a909-3bb4-4722-ac4e-5b5d0a0e4787"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#3ff2a909-3bb4-4722-ac4e-5b5d0a0e4787');

            setTimeout(function() {
                var nbb_cell_id = 5;
                var nbb_unformatted_code = "# export\n@task\ndef untar_cmd(file_path: str, outdir: str) -> str:\n    \"\"\"\n    Untars a .tar.gz file onto a directory (will create it if it does not exist).\n    \"\"\"\n    if os.path.exists(outdir):\n        raise SKIP(\"Output directory already exists.\")\n    return f\"mkdir -p {outdir} && tar -zxf {file_path} -C {outdir}\"\n\n\nuntar = ShellTask(name=\"untar_task\")";
                var nbb_formatted_code = "# export\n@task\ndef untar_cmd(file_path: str, outdir: str) -> str:\n    \"\"\"\n    Untars a .tar.gz file onto a directory (will create it if it does not exist).\n    \"\"\"\n    if os.path.exists(outdir):\n        raise SKIP(\"Output directory already exists.\")\n    return f\"mkdir -p {outdir} && tar -zxf {file_path} -C {outdir}\"\n\n\nuntar = ShellTask(name=\"untar_task\")";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: untar_cmd>" class="doc_header"><code><Task: untar_cmd></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: untar_cmd></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Partitioning-the-files-in-minibatches">Partitioning the files in minibatches<a class="anchor-link" href="#Partitioning-the-files-in-minibatches">&#182;</a></h2><p>Since the tar.gz file may contain a huge amount of MIDI files, we'll partition those files into minibatches that we can process in parallel.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="8c0ec73e-7c9a-4be1-ac26-6bd2b4c63e86"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#8c0ec73e-7c9a-4be1-ac26-6bd2b4c63e86');

            setTimeout(function() {
                var nbb_cell_id = 6;
                var nbb_unformatted_code = "# export\n@task(skip_on_upstream_skip=False)\ndef partition_files(\n    data_path: str, partition_size: int = 100, min_partitions: int = 4\n) -> list:\n    \"\"\"\n    Partitions the midi files in data_path into chunks.\n    \"\"\"\n    midi_files = list(Path(data_path).glob(\"**/*.mid\"))\n    n = len(midi_files)\n    if (n / partition_size) < min_partitions:\n        partition_size = math.ceil(n / min_partitions)\n    logger = prefect.context.get(\"logger\")\n    logger.info(\n        f\"Processing {n} MIDI files partitioned into groups of {partition_size}\"\n    )\n    return [\n        midi_files[i : i + partition_size]\n        for i in range(0, len(midi_files), partition_size)\n    ]";
                var nbb_formatted_code = "# export\n@task(skip_on_upstream_skip=False)\ndef partition_files(\n    data_path: str, partition_size: int = 100, min_partitions: int = 4\n) -> list:\n    \"\"\"\n    Partitions the midi files in data_path into chunks.\n    \"\"\"\n    midi_files = list(Path(data_path).glob(\"**/*.mid\"))\n    n = len(midi_files)\n    if (n / partition_size) < min_partitions:\n        partition_size = math.ceil(n / min_partitions)\n    logger = prefect.context.get(\"logger\")\n    logger.info(\n        f\"Processing {n} MIDI files partitioned into groups of {partition_size}\"\n    )\n    return [\n        midi_files[i : i + partition_size]\n        for i in range(0, len(midi_files), partition_size)\n    ]";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: partition_files>" class="doc_header"><code><Task: partition_files></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: partition_files></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Processing-a-minibatch">Processing a minibatch<a class="anchor-link" href="#Processing-a-minibatch">&#182;</a></h2><p>For each minibatch, we'll go through its MIDI files, parse them, and write them to a separate Parquet file.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="422aaf47-07cd-4097-ae5a-a8cc1fd1cfff"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#422aaf47-07cd-4097-ae5a-a8cc1fd1cfff');

            setTimeout(function() {
                var nbb_cell_id = 7;
                var nbb_unformatted_code = "# export\n@task\ndef process_and_write(mini_batch: Collection[str], outdir: str) -> bytes:\n    \"\"\"\n    Parses a mini batch of MIDI files and writes the results to a parquet file.\n    The filename is determined by `map_index`. Returns the amount of notes it parsed.\n    \"\"\"\n    frame_no = prefect.context.get(\"map_index\")\n    Path(outdir).mkdir(parents=True, exist_ok=True)\n    outfile = f\"{outdir}/out_{frame_no}.parq\"\n\n    logger = prefect.context.get(\"logger\")\n\n    should_append = False\n\n    global total_songs\n    global valid_songs\n    global valid_notes\n    global malformed_songs\n\n    for file in mini_batch:\n        df, processed_notes = parse_midi_file(file)\n        if df is not None:\n            valid_songs += 1\n            valid_notes += processed_notes\n\n            fastparquet.write(outfile, df, compression=\"SNAPPY\", append=should_append)\n            del df\n            should_append = True\n        else:\n            malformed_songs += 1\n            logger.warning(f\"[Minibatch {frame_no}] {file} could not be processed.\")\n\n        total_songs += 1\n        report(logger)\n\n    return outfile";
                var nbb_formatted_code = "# export\n@task\ndef process_and_write(mini_batch: Collection[str], outdir: str) -> bytes:\n    \"\"\"\n    Parses a mini batch of MIDI files and writes the results to a parquet file.\n    The filename is determined by `map_index`. Returns the amount of notes it parsed.\n    \"\"\"\n    frame_no = prefect.context.get(\"map_index\")\n    Path(outdir).mkdir(parents=True, exist_ok=True)\n    outfile = f\"{outdir}/out_{frame_no}.parq\"\n\n    logger = prefect.context.get(\"logger\")\n\n    should_append = False\n\n    global total_songs\n    global valid_songs\n    global valid_notes\n    global malformed_songs\n\n    for file in mini_batch:\n        df, processed_notes = parse_midi_file(file)\n        if df is not None:\n            valid_songs += 1\n            valid_notes += processed_notes\n\n            fastparquet.write(outfile, df, compression=\"SNAPPY\", append=should_append)\n            del df\n            should_append = True\n        else:\n            malformed_songs += 1\n            logger.warning(f\"[Minibatch {frame_no}] {file} could not be processed.\")\n\n        total_songs += 1\n        report(logger)\n\n    return outfile";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: process_and_write>" class="doc_header"><code><Task: process_and_write></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: process_and_write></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Merging-the-parquet-files">Merging the parquet files<a class="anchor-link" href="#Merging-the-parquet-files">&#182;</a></h2><p>Once we have all the minibatches in separate parquet files, merging them into a single dataset is trivial.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="edbdb1d0-cc81-4a84-9531-e1ad5f160dc7"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#edbdb1d0-cc81-4a84-9531-e1ad5f160dc7');

            setTimeout(function() {
                var nbb_cell_id = 8;
                var nbb_unformatted_code = "# export\n@task\ndef combine_parquet_files(files: Collection[str]) -> None:\n    \"\"\"\n    Combines N parquet files with the same schema into another one.\n    \"\"\"\n    fastparquet.writer.merge(files)";
                var nbb_formatted_code = "# export\n@task\ndef combine_parquet_files(files: Collection[str]) -> None:\n    \"\"\"\n    Combines N parquet files with the same schema into another one.\n    \"\"\"\n    fastparquet.writer.merge(files)";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: combine_parquet_files>" class="doc_header"><code><Task: combine_parquet_files></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: combine_parquet_files></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Putting-everything-together">Putting everything together<a class="anchor-link" href="#Putting-everything-together">&#182;</a></h2><p>Now we can build the ETL flow!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="1de6b5d9-1ec7-495c-8438-faf8d9ea962e"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#1de6b5d9-1ec7-495c-8438-faf8d9ea962e');

            setTimeout(function() {
                var nbb_cell_id = 9;
                var nbb_unformatted_code = "# export\n\n\ndef build_etl(cfg):\n    \"\"\"\n    Builds the ETL flow.\n    \"\"\"\n    tar_gz_path = cfg.tar_gz_path\n    outdir = cfg.outdir\n    assert tar_gz_path, \"Config not found: data.etl.tar_gz_path\"\n    assert outdir, \"Config not found: data.etl.outdir\"\n\n    with Flow(\"Neuralmusic Data ETL\") as flow:\n        tar_gz_path = Path(cfg.tar_gz_path).resolve()\n        assert tar_gz_path.exists(), f\"{tar_gz_path} does not exist\"\n        command = untar_cmd(str(tar_gz_path), \"data\")\n        untarred = untar(command=command)\n\n        mini_batches = partition_files(\n            \"data\", partition_size=cfg.partition_size, upstream_tasks=[untarred]\n        )\n\n        partitions = process_and_write.map(mini_batches, outdir=outdir)\n\n        combine_parquet_files(partitions)\n\n    return flow";
                var nbb_formatted_code = "# export\n\n\ndef build_etl(cfg):\n    \"\"\"\n    Builds the ETL flow.\n    \"\"\"\n    tar_gz_path = cfg.tar_gz_path\n    outdir = cfg.outdir\n    assert tar_gz_path, \"Config not found: data.etl.tar_gz_path\"\n    assert outdir, \"Config not found: data.etl.outdir\"\n\n    with Flow(\"Neuralmusic Data ETL\") as flow:\n        tar_gz_path = Path(cfg.tar_gz_path).resolve()\n        assert tar_gz_path.exists(), f\"{tar_gz_path} does not exist\"\n        command = untar_cmd(str(tar_gz_path), \"data\")\n        untarred = untar(command=command)\n\n        mini_batches = partition_files(\n            \"data\", partition_size=cfg.partition_size, upstream_tasks=[untarred]\n        )\n\n        partitions = process_and_write.map(mini_batches, outdir=outdir)\n\n        combine_parquet_files(partitions)\n\n    return flow";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="build_etl" class="doc_header"><code>build_etl</code><a href="https://github.com/codegram/neuralmusic/tree/master/neuralmusic/data/etl.py#L159" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>build_etl</code>(<strong><code>cfg</code></strong>)</p>
</blockquote>
<p>Builds the ETL flow.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># test</span>
<span class="kn">from</span> <span class="nn">testing</span> <span class="kn">import</span> <span class="n">test_eq</span><span class="p">,</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">omegaconf</span> <span class="kn">import</span> <span class="n">OmegaConf</span>
<span class="kn">import</span> <span class="nn">fastparquet</span>

<span class="n">tmp_path</span> <span class="o">=</span> <span class="s2">&quot;/tmp/neuralmusic_etl&quot;</span>

<span class="n">targz_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">(</span><span class="s2">&quot;data/midi.tar.gz&quot;</span><span class="p">)</span>

<span class="n">dot_list</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tar_gz_path=</span><span class="si">{targz_path}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;outdir=</span><span class="si">{tmp_path}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;partition_size=1&quot;</span><span class="p">]</span>
<span class="n">etl_cfg</span> <span class="o">=</span> <span class="n">OmegaConf</span><span class="o">.</span><span class="n">from_dotlist</span><span class="p">(</span><span class="n">dot_list</span><span class="p">)</span>
<span class="n">flow</span> <span class="o">=</span> <span class="n">build_etl</span><span class="p">(</span><span class="n">etl_cfg</span><span class="p">)</span>

<span class="n">init_stats</span><span class="p">()</span>

<span class="n">started_at</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">flow</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">test_eq</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">total_songs</span><span class="p">)</span>
<span class="n">test_eq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">malformed_songs</span><span class="p">)</span>
<span class="n">test_eq</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">valid_songs</span><span class="p">)</span>
<span class="n">test_eq</span><span class="p">(</span><span class="mi">1457</span><span class="p">,</span> <span class="n">valid_notes</span><span class="p">)</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">fastparquet</span><span class="o">.</span><span class="n">ParquetFile</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="n">pitches</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">velocities</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">test_eq</span><span class="p">([</span><span class="s2">&quot;7.11.2&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">],</span> <span class="n">pitches</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="n">test_eq</span><span class="p">([</span><span class="mf">1.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">durations</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="n">test_eq</span><span class="p">([</span><span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">],</span> <span class="n">velocities</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>[2019-12-08 08:38:06,421] INFO - prefect.FlowRunner | Beginning Flow run for &#39;Neuralmusic Data ETL&#39;
[2019-12-08 08:38:06,425] INFO - prefect.FlowRunner | Starting flow run.
[2019-12-08 08:38:06,439] INFO - prefect.TaskRunner | Task &#39;untar_cmd&#39;: Starting task run...
[2019-12-08 08:38:06,443] INFO - prefect.TaskRunner | Task &#39;untar_cmd&#39;: finished task run for task with final state: &#39;Skipped&#39;
[2019-12-08 08:38:06,458] INFO - prefect.TaskRunner | Task &#39;untar_task&#39;: Starting task run...
[2019-12-08 08:38:06,468] INFO - prefect.TaskRunner | Task &#39;untar_task&#39;: finished task run for task with final state: &#39;Skipped&#39;
[2019-12-08 08:38:06,483] INFO - prefect.TaskRunner | Task &#39;partition_files&#39;: Starting task run...
[2019-12-08 08:38:06,487] INFO - prefect.Task: partition_files | Processing 3 MIDI files partitioned into groups of 1
[2019-12-08 08:38:06,494] INFO - prefect.TaskRunner | Task &#39;partition_files&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-08 08:38:06,507] INFO - prefect.TaskRunner | Task &#39;process_and_write&#39;: Starting task run...
[2019-12-08 08:38:06,518] INFO - prefect.TaskRunner | Task &#39;process_and_write[0]&#39;: Starting task run...
[2019-12-08 08:38:07,334] INFO - prefect.Task: process_and_write | [Total Songs]: 1
[2019-12-08 08:38:07,335] INFO - prefect.Task: process_and_write | [Malformed Songs]: 0
[2019-12-08 08:38:07,336] INFO - prefect.Task: process_and_write | [Notes]: 350
[2019-12-08 08:38:07,336] INFO - prefect.Task: process_and_write | [Total Songs / second]: 1.0923736282510996
[2019-12-08 08:38:07,337] INFO - prefect.Task: process_and_write | [Notes / second]: 382.33076988788486
[2019-12-08 08:38:07,345] INFO - prefect.TaskRunner | Task &#39;process_and_write[0]&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-08 08:38:07,357] INFO - prefect.TaskRunner | Task &#39;process_and_write[1]&#39;: Starting task run...
[2019-12-08 08:38:07,685] INFO - prefect.Task: process_and_write | [Total Songs]: 2
[2019-12-08 08:38:07,685] INFO - prefect.Task: process_and_write | [Malformed Songs]: 0
[2019-12-08 08:38:07,686] INFO - prefect.Task: process_and_write | [Notes]: 1162
[2019-12-08 08:38:07,687] INFO - prefect.Task: process_and_write | [Total Songs / second]: 1.5799710058287815
[2019-12-08 08:38:07,687] INFO - prefect.Task: process_and_write | [Notes / second]: 917.963154386522
[2019-12-08 08:38:07,695] INFO - prefect.TaskRunner | Task &#39;process_and_write[1]&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-08 08:38:07,704] INFO - prefect.TaskRunner | Task &#39;process_and_write[2]&#39;: Starting task run...
[2019-12-08 08:38:07,783] INFO - prefect.Task: process_and_write | [Total Songs]: 3
[2019-12-08 08:38:07,783] INFO - prefect.Task: process_and_write | [Malformed Songs]: 0
[2019-12-08 08:38:07,784] INFO - prefect.Task: process_and_write | [Notes]: 1457
[2019-12-08 08:38:07,784] INFO - prefect.Task: process_and_write | [Total Songs / second]: 2.199831327019985
[2019-12-08 08:38:07,785] INFO - prefect.Task: process_and_write | [Notes / second]: 1068.384747822706
[2019-12-08 08:38:07,793] INFO - prefect.TaskRunner | Task &#39;process_and_write[2]&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-08 08:38:07,800] INFO - prefect.TaskRunner | Task &#39;process_and_write&#39;: finished task run for task with final state: &#39;Mapped&#39;
[2019-12-08 08:38:07,811] INFO - prefect.TaskRunner | Task &#39;combine_parquet_files&#39;: Starting task run...
[2019-12-08 08:38:07,821] INFO - prefect.TaskRunner | Task &#39;combine_parquet_files&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-08 08:38:07,825] INFO - prefect.FlowRunner | Flow run SUCCESS: all reference tasks succeeded
</pre>
</div>
</div>

<div class="output_area">




<div id="7df3e9a0-152c-424b-9809-6e293a87ccbf"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#7df3e9a0-152c-424b-9809-6e293a87ccbf');

            setTimeout(function() {
                var nbb_cell_id = 10;
                var nbb_unformatted_code = "# test\nfrom test import test_eq, path\nfrom omegaconf import OmegaConf\nimport fastparquet\n\ntmp_path = \"/tmp/neuralmusic_etl\"\n\ntargz_path = path(\"data/midi.tar.gz\")\n\ndot_list = [f\"tar_gz_path={targz_path}\", f\"outdir={tmp_path}\", \"partition_size=1\"]\netl_cfg = OmegaConf.from_dotlist(dot_list)\nflow = build_etl(etl_cfg)\n\ninit_stats()\n\nstarted_at = time.time()\nflow.run()\n\ntest_eq(3, total_songs)\ntest_eq(0, malformed_songs)\ntest_eq(3, valid_songs)\ntest_eq(1457, valid_notes)\n\ndf = fastparquet.ParquetFile(tmp_path, verify=True).to_pandas()\npitches, durations, velocities = df.values[0]\n\ntest_eq([\"7.11.2\", \"7\", \"7\"], pitches[0:3])\ntest_eq([1.75, 0.5, 0.5], durations[0:3])\ntest_eq([110, 110, 110], velocities[0:3])";
                var nbb_formatted_code = "# test\nfrom test import test_eq, path\nfrom omegaconf import OmegaConf\nimport fastparquet\n\ntmp_path = \"/tmp/neuralmusic_etl\"\n\ntargz_path = path(\"data/midi.tar.gz\")\n\ndot_list = [f\"tar_gz_path={targz_path}\", f\"outdir={tmp_path}\", \"partition_size=1\"]\netl_cfg = OmegaConf.from_dotlist(dot_list)\nflow = build_etl(etl_cfg)\n\ninit_stats()\n\nstarted_at = time.time()\nflow.run()\n\ntest_eq(3, total_songs)\ntest_eq(0, malformed_songs)\ntest_eq(3, valid_songs)\ntest_eq(1457, valid_notes)\n\ndf = fastparquet.ParquetFile(tmp_path, verify=True).to_pandas()\npitches, durations, velocities = df.values[0]\n\ntest_eq([\"7.11.2\", \"7\", \"7\"], pitches[0:3])\ntest_eq([1.75, 0.5, 0.5], durations[0:3])\ntest_eq([110, 110, 110], velocities[0:3])";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
</div>
 

