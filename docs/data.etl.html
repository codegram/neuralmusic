---

title: ETL to process MIDI files
keywords: fastai
sidebar: home_sidebar

summary: "Turning a bunch of MIDI files into parquet data"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02_data.etl.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="51af2db0-2f18-4a93-a809-02f0af2ccdff"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#51af2db0-2f18-4a93-a809-02f0af2ccdff');

            setTimeout(function() {
                var nbb_cell_id = 6;
                var nbb_unformatted_code = "# export\ntotal_songs = 0\nmalformed_songs = 0\nvalid_songs = 0\nvalid_rows = 0\n\nstarted_at = None\n\n\ndef init_stats():\n    \"\"\"\n    Resets reporting stats to zero.\n    \"\"\"\n    global total_songs\n    global valid_songs\n    global valid_rows\n    global malformed_songs\n    global started_at\n\n    total_songs = 0\n    malformed_songs = 0\n    valid_songs = 0\n    valid_rows = 0\n\n    started_at = time.time()\n\n\nif \"SPELL\" in os.environ:\n    metric = spell.metrics.send_metric\n\n    def metric(_logger, k, v):\n        spell.metrics.send_metric(k, v)\n\n\nelse:\n\n    def metric(logger, k, v):\n        logger.info(f\"[{k}]: {v}\")\n\n\ndef report(logger):\n    \"\"\"\n    Reports current metrics, either to Spell or to a logger.\n    \"\"\"\n    elapsed = time.time() - started_at\n    metric(logger, \"Total Songs\", total_songs)\n    metric(logger, \"Malformed Songs\", malformed_songs)\n    metric(logger, \"Songs\", valid_songs)\n    metric(logger, \"Total Songs / second\", (total_songs / elapsed))\n    metric(logger, \"Rows / second\", (valid_rows / elapsed))";
                var nbb_formatted_code = "# export\ntotal_songs = 0\nmalformed_songs = 0\nvalid_songs = 0\nvalid_rows = 0\n\nstarted_at = None\n\n\ndef init_stats():\n    \"\"\"\n    Resets reporting stats to zero.\n    \"\"\"\n    global total_songs\n    global valid_songs\n    global valid_rows\n    global malformed_songs\n    global started_at\n\n    total_songs = 0\n    malformed_songs = 0\n    valid_songs = 0\n    valid_rows = 0\n\n    started_at = time.time()\n\n\nif \"SPELL\" in os.environ:\n    metric = spell.metrics.send_metric\n\n    def metric(_logger, k, v):\n        spell.metrics.send_metric(k, v)\n\n\nelse:\n\n    def metric(logger, k, v):\n        logger.info(f\"[{k}]: {v}\")\n\n\ndef report(logger):\n    \"\"\"\n    Reports current metrics, either to Spell or to a logger.\n    \"\"\"\n    elapsed = time.time() - started_at\n    metric(logger, \"Total Songs\", total_songs)\n    metric(logger, \"Malformed Songs\", malformed_songs)\n    metric(logger, \"Songs\", valid_songs)\n    metric(logger, \"Total Songs / second\", (total_songs / elapsed))\n    metric(logger, \"Rows / second\", (valid_rows / elapsed))";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="init_stats" class="doc_header"><code>init_stats</code><a href="https://github.com/codegram/neuralmusic/tree/master/neuralmusic/data/etl.py#L34" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>init_stats</code>()</p>
</blockquote>
<p>Resets reporting stats to zero.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="report" class="doc_header"><code>report</code><a href="https://github.com/codegram/neuralmusic/tree/master/neuralmusic/data/etl.py#L65" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>report</code>(<strong><code>logger</code></strong>)</p>
</blockquote>
<p>Reports current metrics, either to Spell or to a logger.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Untar'ing-the-file">Untar'ing the file<a class="anchor-link" href="#Untar'ing-the-file">&#182;</a></h2><p>The first step is to untar the file containing the MIDI files.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="4fb2104d-90c8-48c3-8d78-e05481dd6a10"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#4fb2104d-90c8-48c3-8d78-e05481dd6a10');

            setTimeout(function() {
                var nbb_cell_id = 7;
                var nbb_unformatted_code = "# export\n@task\ndef untar_cmd(file_path: str, outdir: str) -> str:\n    \"\"\"\n    Untars a .tar.gz file onto a directory (will create it if it does not exist).\n    \"\"\"\n    if os.path.exists(outdir):\n        raise SKIP(\"Output directory already exists.\")\n    return f\"mkdir -p {outdir} && tar -zxf {file_path} -C {outdir}\"\n\n\nuntar = ShellTask(name=\"untar_task\")";
                var nbb_formatted_code = "# export\n@task\ndef untar_cmd(file_path: str, outdir: str) -> str:\n    \"\"\"\n    Untars a .tar.gz file onto a directory (will create it if it does not exist).\n    \"\"\"\n    if os.path.exists(outdir):\n        raise SKIP(\"Output directory already exists.\")\n    return f\"mkdir -p {outdir} && tar -zxf {file_path} -C {outdir}\"\n\n\nuntar = ShellTask(name=\"untar_task\")";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: untar_cmd>" class="doc_header"><code><Task: untar_cmd></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: untar_cmd></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Partitioning-the-files-in-minibatches">Partitioning the files in minibatches<a class="anchor-link" href="#Partitioning-the-files-in-minibatches">&#182;</a></h2><p>Since the tar.gz file may contain a huge amount of MIDI files, we'll partition those files into minibatches that we can process in parallel.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="3d719643-bfbd-4cc8-8627-e08729bfc6a2"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#3d719643-bfbd-4cc8-8627-e08729bfc6a2');

            setTimeout(function() {
                var nbb_cell_id = 8;
                var nbb_unformatted_code = "# export\n@task(skip_on_upstream_skip=False)\ndef partition_files(\n    data_path: str, partition_size: int = 100, min_partitions: int = 4\n) -> list:\n    \"\"\"\n    Partitions the midi files in data_path into chunks.\n    \"\"\"\n    midi_files = list(Path(data_path).glob(\"**/*.mid\"))\n    n = len(midi_files)\n    if (n / partition_size) < min_partitions:\n        partition_size = math.ceil(n / min_partitions)\n    logger = prefect.context.get(\"logger\")\n    logger.info(\n        f\"Processing {n} MIDI files partitioned into groups of {partition_size}\"\n    )\n    return [\n        midi_files[i : i + partition_size]\n        for i in range(0, len(midi_files), partition_size)\n    ]";
                var nbb_formatted_code = "# export\n@task(skip_on_upstream_skip=False)\ndef partition_files(\n    data_path: str, partition_size: int = 100, min_partitions: int = 4\n) -> list:\n    \"\"\"\n    Partitions the midi files in data_path into chunks.\n    \"\"\"\n    midi_files = list(Path(data_path).glob(\"**/*.mid\"))\n    n = len(midi_files)\n    if (n / partition_size) < min_partitions:\n        partition_size = math.ceil(n / min_partitions)\n    logger = prefect.context.get(\"logger\")\n    logger.info(\n        f\"Processing {n} MIDI files partitioned into groups of {partition_size}\"\n    )\n    return [\n        midi_files[i : i + partition_size]\n        for i in range(0, len(midi_files), partition_size)\n    ]";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: partition_files>" class="doc_header"><code><Task: partition_files></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: partition_files></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Processing-a-minibatch">Processing a minibatch<a class="anchor-link" href="#Processing-a-minibatch">&#182;</a></h2><p>For each minibatch, we'll go through its MIDI files, parse them, and write them to a separate Parquet file.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="b680ceff-86fb-4247-8964-99abe591e6a3"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#b680ceff-86fb-4247-8964-99abe591e6a3');

            setTimeout(function() {
                var nbb_cell_id = 14;
                var nbb_unformatted_code = "# export\n@task\ndef process_and_write(mini_batch: Collection[str], outdir: str) -> bytes:\n    \"\"\"\n    Parses a mini batch of MIDI files and writes the results to a parquet file.\n    The filename is determined by `map_index`. Returns the amount of notes it parsed.\n    \"\"\"\n    frame_no = prefect.context.get(\"map_index\")\n    Path(outdir).mkdir(parents=True, exist_ok=True)\n    outfile = f\"{outdir}/out_{frame_no}.parq\"\n\n    logger = prefect.context.get(\"logger\")\n\n    should_append = False\n\n    global total_songs\n    global valid_songs\n    global valid_rows\n    global malformed_songs\n\n    for file in mini_batch:\n        df = parse_midi_file(file)\n        if df is not None:\n            valid_songs += 1\n            valid_rows += len(df)\n\n            fastparquet.write(outfile, df, compression=\"SNAPPY\", append=should_append)\n            del df\n            should_append = True\n        else:\n            malformed_songs += 1\n            logger.warning(f\"[Minibatch {frame_no}] {file} could not be processed.\")\n\n        total_songs += 1\n        report(logger)\n\n    return outfile";
                var nbb_formatted_code = "# export\n@task\ndef process_and_write(mini_batch: Collection[str], outdir: str) -> bytes:\n    \"\"\"\n    Parses a mini batch of MIDI files and writes the results to a parquet file.\n    The filename is determined by `map_index`. Returns the amount of notes it parsed.\n    \"\"\"\n    frame_no = prefect.context.get(\"map_index\")\n    Path(outdir).mkdir(parents=True, exist_ok=True)\n    outfile = f\"{outdir}/out_{frame_no}.parq\"\n\n    logger = prefect.context.get(\"logger\")\n\n    should_append = False\n\n    global total_songs\n    global valid_songs\n    global valid_rows\n    global malformed_songs\n\n    for file in mini_batch:\n        df = parse_midi_file(file)\n        if df is not None:\n            valid_songs += 1\n            valid_rows += len(df)\n\n            fastparquet.write(outfile, df, compression=\"SNAPPY\", append=should_append)\n            del df\n            should_append = True\n        else:\n            malformed_songs += 1\n            logger.warning(f\"[Minibatch {frame_no}] {file} could not be processed.\")\n\n        total_songs += 1\n        report(logger)\n\n    return outfile";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: process_and_write>" class="doc_header"><code><Task: process_and_write></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: process_and_write></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Merging-the-parquet-files">Merging the parquet files<a class="anchor-link" href="#Merging-the-parquet-files">&#182;</a></h2><p>Once we have all the minibatches in separate parquet files, merging them into a single dataset is trivial.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="1394153e-9f95-40cb-91e5-939a4854e1ff"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#1394153e-9f95-40cb-91e5-939a4854e1ff');

            setTimeout(function() {
                var nbb_cell_id = 15;
                var nbb_unformatted_code = "# export\n@task\ndef combine_parquet_files(files: Collection[str]) -> None:\n    \"\"\"\n    Combines N parquet files with the same schema into another one.\n    \"\"\"\n    fastparquet.writer.merge(files)";
                var nbb_formatted_code = "# export\n@task\ndef combine_parquet_files(files: Collection[str]) -> None:\n    \"\"\"\n    Combines N parquet files with the same schema into another one.\n    \"\"\"\n    fastparquet.writer.merge(files)";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="<Task: combine_parquet_files>" class="doc_header"><code><Task: combine_parquet_files></code><a href="" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code><Task: combine_parquet_files></code>(<strong>*<code>args</code></strong>:<code>Any</code>, <strong><code>mapped</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>task_args</code></strong>:<code>dict</code>=<em><code>None</code></em>, <strong><code>upstream_tasks</code></strong>:<code>Iterable</code>[<code>Any</code>]=<em><code>None</code></em>, <strong><code>flow</code></strong>:<code>Flow</code>=<em><code>None</code></em>, <strong>**<code>kwargs</code></strong>:<code>Any</code>)</p>
</blockquote>
<p>A convenience Task for functionally creating Task instances with
arbitrary callable <code>run</code> methods.</p>
<p>Args:</p>

<pre><code>- fn (callable): the function to be the task's `run` method
- name (str, optional): the name of this task
- **kwargs: keyword arguments that will be passed to the Task
    constructor

</code></pre>
<p>Raises:</p>

<pre><code>- ValueError: if the provided function violates signature requirements
    for Task run methods

</code></pre>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">FunctionTask</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">42</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Subtract 42&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Flow</span><span class="p">(</span><span class="s2">&quot;My Flow&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Putting-everything-together">Putting everything together<a class="anchor-link" href="#Putting-everything-together">&#182;</a></h2><p>Now we can build the ETL flow!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">




<div id="ba5e3193-cc36-4aa9-9f07-abdc351e2dcf"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#ba5e3193-cc36-4aa9-9f07-abdc351e2dcf');

            setTimeout(function() {
                var nbb_cell_id = 16;
                var nbb_unformatted_code = "# export\n\n\ndef build_etl(cfg):\n    \"\"\"\n    Builds the ETL flow.\n    \"\"\"\n    tar_gz_path = cfg.tar_gz_path\n    outdir = cfg.outdir\n    assert tar_gz_path, \"Config not found: data.etl.tar_gz_path\"\n    assert outdir, \"Config not found: data.etl.outdir\"\n\n    with Flow(\"Neuralmusic Data ETL\") as flow:\n        tar_gz_path = Path(cfg.tar_gz_path).resolve()\n        assert tar_gz_path.exists(), f\"{tar_gz_path} does not exist\"\n        command = untar_cmd(str(tar_gz_path), \"data\")\n        untarred = untar(command=command)\n\n        mini_batches = partition_files(\n            \"data\", partition_size=cfg.partition_size, upstream_tasks=[untarred]\n        )\n\n        partitions = process_and_write.map(mini_batches, outdir=outdir)\n\n        combine_parquet_files(partitions)\n\n    return flow";
                var nbb_formatted_code = "# export\n\n\ndef build_etl(cfg):\n    \"\"\"\n    Builds the ETL flow.\n    \"\"\"\n    tar_gz_path = cfg.tar_gz_path\n    outdir = cfg.outdir\n    assert tar_gz_path, \"Config not found: data.etl.tar_gz_path\"\n    assert outdir, \"Config not found: data.etl.outdir\"\n\n    with Flow(\"Neuralmusic Data ETL\") as flow:\n        tar_gz_path = Path(cfg.tar_gz_path).resolve()\n        assert tar_gz_path.exists(), f\"{tar_gz_path} does not exist\"\n        command = untar_cmd(str(tar_gz_path), \"data\")\n        untarred = untar(command=command)\n\n        mini_batches = partition_files(\n            \"data\", partition_size=cfg.partition_size, upstream_tasks=[untarred]\n        )\n\n        partitions = process_and_write.map(mini_batches, outdir=outdir)\n\n        combine_parquet_files(partitions)\n\n    return flow";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="build_etl" class="doc_header"><code>build_etl</code><a href="https://github.com/codegram/neuralmusic/tree/master/neuralmusic/data/etl.py#L159" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>build_etl</code>(<strong><code>cfg</code></strong>)</p>
</blockquote>
<p>Builds the ETL flow.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># test</span>
<span class="kn">from</span> <span class="nn">testing</span> <span class="kn">import</span> <span class="n">test_eq</span><span class="p">,</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">omegaconf</span> <span class="kn">import</span> <span class="n">OmegaConf</span>
<span class="kn">import</span> <span class="nn">fastparquet</span>

<span class="n">tmp_path</span> <span class="o">=</span> <span class="s2">&quot;/tmp/neuralmusic_etl&quot;</span>

<span class="n">targz_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">(</span><span class="s2">&quot;data/midi.tar.gz&quot;</span><span class="p">)</span>

<span class="n">dot_list</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tar_gz_path=</span><span class="si">{targz_path}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;outdir=</span><span class="si">{tmp_path}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;partition_size=1&quot;</span><span class="p">]</span>
<span class="n">etl_cfg</span> <span class="o">=</span> <span class="n">OmegaConf</span><span class="o">.</span><span class="n">from_dotlist</span><span class="p">(</span><span class="n">dot_list</span><span class="p">)</span>
<span class="n">flow</span> <span class="o">=</span> <span class="n">build_etl</span><span class="p">(</span><span class="n">etl_cfg</span><span class="p">)</span>

<span class="n">init_stats</span><span class="p">()</span>

<span class="n">started_at</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">flow</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">test_eq</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">total_songs</span><span class="p">)</span>
<span class="n">test_eq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">malformed_songs</span><span class="p">)</span>
<span class="n">test_eq</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">valid_songs</span><span class="p">)</span>
<span class="n">test_eq</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">valid_rows</span><span class="p">)</span>


<span class="n">df</span> <span class="o">=</span> <span class="n">fastparquet</span><span class="o">.</span><span class="n">ParquetFile</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="n">test_eq</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>

<span class="c1"># TODO: figure out order!</span>
<span class="c1"># test_eq([&quot;7.11.2&quot;, &quot;7&quot;, &quot;7&quot;], pitches[0:3])</span>
<span class="c1"># test_eq([1.75, 0.5, 0.5], durations[0:3])</span>
<span class="c1"># test_eq([110, 110, 110], velocities[0:3])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>[2019-12-15 06:48:02,998] INFO - prefect.FlowRunner | Beginning Flow run for &#39;Neuralmusic Data ETL&#39;
[2019-12-15 06:48:03,005] INFO - prefect.FlowRunner | Starting flow run.
[2019-12-15 06:48:03,022] INFO - prefect.TaskRunner | Task &#39;untar_cmd&#39;: Starting task run...
[2019-12-15 06:48:03,031] INFO - prefect.TaskRunner | Task &#39;untar_cmd&#39;: finished task run for task with final state: &#39;Skipped&#39;
[2019-12-15 06:48:03,051] INFO - prefect.TaskRunner | Task &#39;untar_task&#39;: Starting task run...
[2019-12-15 06:48:03,058] INFO - prefect.TaskRunner | Task &#39;untar_task&#39;: finished task run for task with final state: &#39;Skipped&#39;
[2019-12-15 06:48:03,072] INFO - prefect.TaskRunner | Task &#39;partition_files&#39;: Starting task run...
[2019-12-15 06:48:03,074] INFO - prefect.Task: partition_files | Processing 4 MIDI files partitioned into groups of 1
[2019-12-15 06:48:03,084] INFO - prefect.TaskRunner | Task &#39;partition_files&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-15 06:48:03,097] INFO - prefect.TaskRunner | Task &#39;process_and_write&#39;: Starting task run...
[2019-12-15 06:48:03,113] INFO - prefect.TaskRunner | Task &#39;process_and_write[0]&#39;: Starting task run...
[2019-12-15 06:48:03,761] INFO - prefect.Task: process_and_write | [Total Songs]: 1
[2019-12-15 06:48:03,762] INFO - prefect.Task: process_and_write | [Malformed Songs]: 0
[2019-12-15 06:48:03,762] INFO - prefect.Task: process_and_write | [Songs]: 1
[2019-12-15 06:48:03,763] INFO - prefect.Task: process_and_write | [Total Songs / second]: 1.3101386259847192
[2019-12-15 06:48:03,764] INFO - prefect.Task: process_and_write | [Rows / second]: 1.3101386259847192
[2019-12-15 06:48:03,771] INFO - prefect.TaskRunner | Task &#39;process_and_write[0]&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-15 06:48:03,778] INFO - prefect.TaskRunner | Task &#39;process_and_write[1]&#39;: Starting task run...
[2019-12-15 06:48:05,166] INFO - prefect.Task: process_and_write | [Total Songs]: 2
[2019-12-15 06:48:05,167] INFO - prefect.Task: process_and_write | [Malformed Songs]: 0
[2019-12-15 06:48:05,167] INFO - prefect.Task: process_and_write | [Songs]: 2
[2019-12-15 06:48:05,168] INFO - prefect.Task: process_and_write | [Total Songs / second]: 0.9222680476523394
[2019-12-15 06:48:05,169] INFO - prefect.Task: process_and_write | [Rows / second]: 0.9222680476523394
[2019-12-15 06:48:05,176] INFO - prefect.TaskRunner | Task &#39;process_and_write[1]&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-15 06:48:05,185] INFO - prefect.TaskRunner | Task &#39;process_and_write[2]&#39;: Starting task run...
[2019-12-15 06:48:06,140] INFO - prefect.Task: process_and_write | [Total Songs]: 3
[2019-12-15 06:48:06,141] INFO - prefect.Task: process_and_write | [Malformed Songs]: 0
[2019-12-15 06:48:06,141] INFO - prefect.Task: process_and_write | [Songs]: 3
[2019-12-15 06:48:06,142] INFO - prefect.Task: process_and_write | [Total Songs / second]: 0.954573427184572
[2019-12-15 06:48:06,143] INFO - prefect.Task: process_and_write | [Rows / second]: 0.954573427184572
[2019-12-15 06:48:06,150] INFO - prefect.TaskRunner | Task &#39;process_and_write[2]&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-15 06:48:06,157] INFO - prefect.TaskRunner | Task &#39;process_and_write[3]&#39;: Starting task run...
[2019-12-15 06:48:06,739] INFO - prefect.Task: process_and_write | [Total Songs]: 4
[2019-12-15 06:48:06,740] INFO - prefect.Task: process_and_write | [Malformed Songs]: 0
[2019-12-15 06:48:06,741] INFO - prefect.Task: process_and_write | [Songs]: 4
[2019-12-15 06:48:06,741] INFO - prefect.Task: process_and_write | [Total Songs / second]: 1.069037375364476
[2019-12-15 06:48:06,743] INFO - prefect.Task: process_and_write | [Rows / second]: 1.069037375364476
[2019-12-15 06:48:06,750] INFO - prefect.TaskRunner | Task &#39;process_and_write[3]&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-15 06:48:06,755] INFO - prefect.TaskRunner | Task &#39;process_and_write&#39;: finished task run for task with final state: &#39;Mapped&#39;
[2019-12-15 06:48:06,767] INFO - prefect.TaskRunner | Task &#39;combine_parquet_files&#39;: Starting task run...
[2019-12-15 06:48:06,781] INFO - prefect.TaskRunner | Task &#39;combine_parquet_files&#39;: finished task run for task with final state: &#39;Success&#39;
[2019-12-15 06:48:06,783] INFO - prefect.FlowRunner | Flow run SUCCESS: all reference tasks succeeded
</pre>
</div>
</div>

<div class="output_area">




<div id="dd825af4-239a-4c5f-9cae-ade37b92d145"></div>
<div class="output_subarea output_javascript ">
<script type="text/javascript">
var element = $('#dd825af4-239a-4c5f-9cae-ade37b92d145');

            setTimeout(function() {
                var nbb_cell_id = 19;
                var nbb_unformatted_code = "# test\nfrom testing import test_eq, path\nfrom omegaconf import OmegaConf\nimport fastparquet\n\ntmp_path = \"/tmp/neuralmusic_etl\"\n\ntargz_path = path(\"data/midi.tar.gz\")\n\ndot_list = [f\"tar_gz_path={targz_path}\", f\"outdir={tmp_path}\", \"partition_size=1\"]\netl_cfg = OmegaConf.from_dotlist(dot_list)\nflow = build_etl(etl_cfg)\n\ninit_stats()\n\nstarted_at = time.time()\nflow.run()\n\ntest_eq(4, total_songs)\ntest_eq(0, malformed_songs)\ntest_eq(4, valid_songs)\ntest_eq(4, valid_rows)\n\n\ndf = fastparquet.ParquetFile(tmp_path, verify=True).to_pandas()\ntest_eq(4, len(df))\n\n# TODO: figure out order!\n# test_eq([\"7.11.2\", \"7\", \"7\"], pitches[0:3])\n# test_eq([1.75, 0.5, 0.5], durations[0:3])\n# test_eq([110, 110, 110], velocities[0:3])";
                var nbb_formatted_code = "# test\nfrom testing import test_eq, path\nfrom omegaconf import OmegaConf\nimport fastparquet\n\ntmp_path = \"/tmp/neuralmusic_etl\"\n\ntargz_path = path(\"data/midi.tar.gz\")\n\ndot_list = [f\"tar_gz_path={targz_path}\", f\"outdir={tmp_path}\", \"partition_size=1\"]\netl_cfg = OmegaConf.from_dotlist(dot_list)\nflow = build_etl(etl_cfg)\n\ninit_stats()\n\nstarted_at = time.time()\nflow.run()\n\ntest_eq(4, total_songs)\ntest_eq(0, malformed_songs)\ntest_eq(4, valid_songs)\ntest_eq(4, valid_rows)\n\n\ndf = fastparquet.ParquetFile(tmp_path, verify=True).to_pandas()\ntest_eq(4, len(df))\n\n# TODO: figure out order!\n# test_eq([\"7.11.2\", \"7\", \"7\"], pitches[0:3])\n# test_eq([1.75, 0.5, 0.5], durations[0:3])\n# test_eq([110, 110, 110], velocities[0:3])";
                var nbb_cells = Jupyter.notebook.get_cells();
                for (var i = 0; i < nbb_cells.length; ++i) {
                    if (nbb_cells[i].input_prompt_number == nbb_cell_id) {
                        if (nbb_cells[i].get_text() == nbb_unformatted_code) {
                             nbb_cells[i].set_text(nbb_formatted_code);
                        }
                        break;
                    }
                }
            }, 500);
            
</script>
</div>

</div>

</div>
</div>

</div>
</div>
 

