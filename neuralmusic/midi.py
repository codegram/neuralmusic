#AUTOGENERATED! DO NOT EDIT! File to edit: dev/01_midi.ipynb (unless otherwise specified).

__all__ = ['Triplet', 'parse_midi_file', 'row_to_triplets', 'triplet_to_note', 'triplets_to_stream', 'write_midi']

#Cell
from typing import Optional, Tuple, Collection
import re

from music21 import (
    converter,
    instrument,
    note,
    chord,
    pitch,
    interval,
    stream,
    volume,
    duration,
    midi,
    meter,
    key,
    tempo,
)
from music21.midi import MidiException
import pandas as pd

#Cell

Pitch, Duration, Velocity = str, float, int
Triplet = Tuple[Pitch, Duration, Velocity]

#Cell


def _parse_duration(d: duration.Duration) -> Optional[str]:
    try:
        dur = float(d.quarterLength)
        name = d.type
        if dur > 0.0 and dur <= 32.0 and name != "inexpressible":
            return name
        else:
            return None
    except duration.DurationException:
        return None


def _parse_single_note(note: note.Note) -> Optional[Triplet]:
    dur = _parse_duration(note.duration)
    if dur is not None:
        return (str(note.pitch), dur, note.volume.velocity)
    else:
        return None


def _parse_chord(chord: chord.Chord) -> Optional[Triplet]:
    dur = _parse_duration(chord.duration)
    if dur is not None:
        return (".".join(str(n) for n in chord.normalOrder), dur, chord.volume.velocity)
    else:
        return None


def _parse_rest(rest: note.Rest) -> Optional[Triplet]:
    dur = _parse_duration(rest.duration)
    if dur is not None:
        return ("R", dur, 0)
    else:
        return None

#Cell


def _transpose_to_C(s: stream.Stream) -> (stream.Stream, str):
    "Normalizes a stream to the C key, and returns the mode"
    k = s.analyze("key")
    i = interval.Interval(k.tonic, pitch.Pitch("C"))
    return s.transpose(i), k.mode

#Cell


def _parse_part(elements, mode) -> Optional[dict]:
    d = {
        "notes": [],
        "instrument": "unknown",
        "bpm": 120,
        "time_signature": "4/4",
        "mode": mode,
    }

    for element in elements:
        if element.__class__ == note.Note:
            x = _parse_single_note(element)
            if x is not None:
                d["notes"].append(x)
        elif element.__class__ == chord.Chord:
            x = _parse_chord(element)
            if x is not None:
                d["notes"].append(x)
        elif element.__class__ == note.Rest:
            x = _parse_rest(element)
            if x is not None:
                d["notes"].append(x)
        elif isinstance(element, instrument.Instrument):
            if str(element) != "":
                d["instrument"] = str(element).lower()
        elif element.__class__ == tempo.MetronomeMark:
            d["bpm"] = element.number
        elif element.__class__ == meter.TimeSignature:
            d["time_signature"] = element.ratioString

    if len(d["notes"]) != 0:
        return d
    else:
        return None

#Cell


def parse_midi_file(file: str) -> Optional[pd.DataFrame]:
    """
    Attempts to parse a midi file into a Dataframe. Returns a Dataframe or None, together with the number of notes processed.
    """
    try:
        midi, mode = _transpose_to_C(converter.parse(file))
        parts = instrument.partitionByInstrument(midi)
        rows = []
        if parts:
            for part in parts:
                parsed = _parse_part(part.recurse(), mode)
                if parsed is not None:
                    rows.append(parsed)
        else:
            parsed = _parse_part(midi.flat.notes, mode)
            if parsed is not None:
                rows.append(parsed)

        for row in rows:
            row["pitches"] = [pitch for (pitch, dur, velocity) in row["notes"]]
            row["durations"] = [dur for (pitch, dur, velocity) in row["notes"]]
            row["velocities"] = [velocity for (pitch, dur, velocity) in row["notes"]]
            del row["notes"]

        return pd.DataFrame(rows)
    except MidiException:
        return None
    except IndexError:
        return None


def row_to_triplets(df: pd.DataFrame, row_index: int) -> Collection[Triplet]:
    """
    Takes a DataFrame at a specific row and turns that into a triplet.
    """
    pitches = df.get("pitches")[row_index]
    durations = df.get("durations")[row_index]
    velocities = df.get("velocities")[row_index]
    return list(zip(pitches, durations, velocities))

#Cell


def triplet_to_note(triplet: Triplet):
    pitch, dur, vel = triplet
    dur = duration.Duration(dur)
    vol = volume.Volume(velocity=vel)
    if re.match(r"^[0-9]", pitch):
        c = chord.Chord([int(x) for x in pitch.split(".")], duration=dur)
        c.volume = vol
        return c
    elif pitch == "R":
        return note.Rest(duration=dur)
    else:
        n = note.Note(pitch, duration=dur)
        n.volume = vol
        return n


def triplets_to_stream(triplets: Collection[Triplet]) -> stream.Stream:
    s = stream.Stream()
    _ = [s.append(triplet_to_note(triplet)) for triplet in triplets]
    return s


def write_midi(stream, name):
    mf = midi.translate.streamToMidiFile(stream)
    mf.open(f"{name}.mid", "wb")
    mf.write()
    mf.close()