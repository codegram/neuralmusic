#AUTOGENERATED! DO NOT EDIT! File to edit: dev/01_midi.ipynb (unless otherwise specified).

__all__ = ['Triplet', 'parse_single_note', 'parse_chord', 'parse_rest', 'parse_midi_file', 'row_to_triplets',
           'triplet_to_note', 'triplets_to_stream', 'write_midi']

#Cell
from typing import Optional, Tuple, Collection
import re

from music21 import converter, instrument, note, chord, stream, volume, duration, midi
from music21.midi import MidiException
import pandas as pd

#Cell

Pitch, Duration, Velocity = str, float, int
Triplet = Tuple[Pitch, Duration, Velocity]

#Cell


def parse_single_note(note: note.Note) -> Triplet:
    return (str(note.pitch), float(note.duration.quarterLength), note.volume.velocity)


def parse_chord(chord: chord.Chord) -> Triplet:
    return (
        ".".join(str(n) for n in chord.normalOrder),
        float(chord.duration.quarterLength),
        chord.volume.velocity,
    )


def parse_rest(rest: note.Rest) -> Triplet:
    return ("R", float(rest.duration.quarterLength), 0)

#Cell


def parse_midi_file(file: str) -> (Optional[pd.DataFrame], int):
    """
    Attempts to parse a midi file into a Dataframe. Returns a Dataframe or None, together with the number of notes processed.
    """
    try:
        midi = converter.parse(file)
        notes_to_parse = None
        parts = instrument.partitionByInstrument(midi)
        notes = []
        if parts:  # file has instrument parts
            notes_to_parse = parts.parts[0].recurse()
        else:  # file has notes in a flat structure
            notes_to_parse = midi.flat.notes
        for element in notes_to_parse:
            if element.__class__ == note.Note:
                notes.append(parse_single_note(element))
            elif element.__class__ == chord.Chord:
                notes.append(parse_chord(element))
            elif element.__class__ == note.Rest:
                notes.append(parse_rest(element))

        df = pd.DataFrame.from_dict(
            {
                "pitches": [[[pitch for (pitch, dur, velocity) in notes]]],
                "durations": [[[dur for (pitch, dur, velocity) in notes]]],
                "velocities": [[[velocity for (pitch, dur, velocity) in notes]]],
            }
        )
        return (df, len(notes))
    except MidiException:
        return (None, 0)
    except IndexError:
        return (None, 0)


def row_to_triplets(df: pd.DataFrame, row_index: int) -> Collection[Triplet]:
    """
    Takes a DataFrame at a specific row and turns that into a triplet.
    """
    pitches, durations, velocities = df.values[row_index]
    pitches = pitches[0]
    durations = durations[0]
    velocities = velocities[0]
    return list(zip(pitches, durations, velocities))

#Cell


def triplet_to_note(triplet: Triplet):
    pitch, dur, vel = triplet
    dur = duration.Duration(dur)
    vol = volume.Volume(velocity=vel)
    if re.match(r"^[0-9]", pitch):
        c = chord.Chord([int(x) for x in pitch.split(".")], duration=dur)
        c.volume = vol
        return c
    elif pitch == "R":
        return note.Rest(duration=dur)
    else:
        n = note.Note(pitch, duration=dur)
        n.volume = vol
        return n


def triplets_to_stream(triplets: Collection[Triplet]) -> stream.Stream:
    s = stream.Stream()
    _ = [s.append(triplet_to_note(triplet)) for triplet in triplets]
    return s


def write_midi(stream, name):
    mf = midi.translate.streamToMidiFile(stream)
    mf.open(f"{name}.mid", "wb")
    mf.write()
    mf.close()